Name: TÄƒiatu Iulian-Marius, 332CB

# Homework 1 ACS - Marketplace - MPMC

## Workflow
This application is a Multi Porducer Multi Consumer (MPMC) simulation. The program is written in Python and uses the [theading](https://docs.python.org/3/library/threading.html) module to create threads.

The program is divided into 3 main parts: the `Producer`, the `Consumer` and the `Marketplace`. The `Marketplace` is the main part of the application, it is responsible for storing the data generated by the `Producer` and consumed by the `Consumer`.

The `Producer`s are responsible for generating data and adding it to the `Marketplace`. The `Consumer`s are responsible for consuming data from the `Marketplace`.

## Implementation

The `Marketplace` exposes different methods for the `Producer`s and `Consumer`s to interact with it. The `Producer`s can be registered to the `Marketplace` and they can add data to it. The `Consumer`s can be add products to the `Cart` and they can remove products from the `Cart`. Also, they can place the order when they are done or they can cancel the order if they are not satisfied with the products.

Each producer has a products limit `queue_size_per_producer` which represents the maximum number of products that can be published by the producer. If the queue is full, the producer will wait until a consumer consumes some products.

The application runs in a `multi-threaded` fashion, each `Producer` and `Consumer` is a thread. The `Marketplace` is a shared resource between the `Producer`s and `Consumer`s. 

Therefore, different synchronization mechanisms are used to ensure that the data is not corrupted. The `Marketplace` uses locks to synchronize the access to the data

- `register_producer_lock` - used to synchronize the generation of the producer IDs
- `new_cart_lock` - used to synchronize the generation of the cart IDs
- `add_to_cart_lock` - used to synchronize the addition of products to the cart

The `Consumer` also uses a lock to synchronize the [print()](https://docs.python.org/3/library/functions.html#print) function.

## Logger

For debugging purposes, the application uses a logger. The logger is used to log the actions of the `Marketplace` and is implemented using the [logging](https://docs.python.org/3/library/logging.html) module.

The logger has the advantage that it is thread-safe by default, so it can be used in a multi-threaded environment.

It uses in addition with a [RotatingFileHandler](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.RotatingFileHandler) to log the actions of the `Marketplace` to a file. The files is rotated when it reaches a certain size.

The `INFO` level is used and the logger is configured to print the actions in the `GMT` timezone for easier debugging between servers from different timezones.

## Unit tests

For testing purposes, the application uses unit tests. The unit tests are implemented using the [unittest](https://docs.python.org/3/library/unittest.html) module.

The unittest are used to test each component of the `Marketplace` class, by simulating different scenarios.

`setUp()` method is called before tests are started and it is used to initialize the `Marketplace` object. It initializes the `Marketplace` with some basic producers and products. This allows the tests to be independent from each other and have a base state to start from.
 
## Conclusion

The application is a simulation of a marketplace. It uses the `threading` module to create threads for the `Producer`s and `Consumer`s. The `Marketplace` is a shared resource between the `Producer`s and `Consumer`s. Therefore, different synchronization mechanisms are used to ensure that the data is not corrupted.

The application uses a logger to log the actions of the `Marketplace` and it is implemented using the `logging` module. The logger has the advantage that it is thread-safe by default, so it can be used in a multi-threaded environment.

The application uses unit tests to test each component of the `Marketplace` class, by simulating different scenarios.

An interesting further comparison would be to implement the same application in a single-threaded fashion and compare the performance and scalability. This will allow us to see the advantages of using a multi-threaded environment for those applications which can benefit from it.

## References

- [theading](https://docs.python.org/3/library/threading.html)
- [logging](https://docs.python.org/3/library/logging.html)
- [RotatingFileHandler](https://docs.python.org/3/library/logging.handlers.html#logging.handlers.RotatingFileHandler)
- [unittest](https://docs.python.org/3/library/unittest.html)
- [MPMC](https://superfastpython.com/thread-producer-consumer-pattern-in-python/)